#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <linux/if_alg.h>
#include <linux/socket.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <stdint.h>
#include <assert.h>
#include <fcntl.h>
#include <limits.h>

#include "af_alg.h"

struct gcm_test_vector {
	uint8_t key[AES_KEY256_SIZE];
	uint8_t iv[AES_IV_SIZE];
	uint8_t assocdata[5 * AES_BLOCK_SIZE];
	uint8_t in_cryptdata[5 * AES_BLOCK_SIZE];
	uint8_t out_cryptdata[5 * AES_BLOCK_SIZE];
	uint8_t tag[GCM_TAGLEN];
	unsigned int keylen;
	unsigned int ivlen;
	unsigned int assoclen;
	unsigned int cryptlen;
	unsigned int taglen;
};

static struct gcm_test_vector gcm_vecs[] = {
{
	.key = {
		0x48, 0xb7, 0xf3, 0x37, 0xcd, 0xf9, 0x25, 0x26, 0x87, 0xec, 0xc7, 0x60, 0xbd, 0x8e, 0xc1, 0x84,
	},
	.keylen = AES_KEY128_SIZE,
	.iv = {
		0x3e, 0x89, 0x4e, 0xbb, 0x16, 0xce, 0x82, 0xa5, 0x3c, 0x3e, 0x05, 0xb2,
	},
	.ivlen = GCM_IV_SIZE,
	.in_cryptdata = {
		0xbb, 0x2b, 0xac, 0x67, 0xa4, 0x70, 0x94, 0x30, 0xc3, 0x9c, 0x2e, 0xb9, 0xac, 0xfa, 0xbc, 0x0d,
		0x45, 0x6c, 0x80, 0xd3, 0x0a, 0xa1, 0x73, 0x4e, 0x57, 0x99, 0x7d, 0x54, 0x8a, 0x8f, 0x06, 0x03,
	},
	.cryptlen = 2 * AES_BLOCK_SIZE,
	.assocdata = {
		0x7d, 0x92, 0x4c, 0xfd, 0x37, 0xb3, 0xd0, 0x46, 0xa9, 0x6e, 0xb5, 0xe1, 0x32, 0x04, 0x24, 0x05,
		0xc8, 0x73, 0x1e, 0x06, 0x50, 0x97, 0x87, 0xbb, 0xeb, 0x41, 0xf2, 0x58, 0x27, 0x57, 0x46, 0x49,
		0x5e, 0x88, 0x4d, 0x69, 0x87, 0x1f, 0x77, 0x63, 0x4c, 0x58, 0x4b, 0xb0, 0x07, 0x31, 0x22, 0x34,
	},
	.assoclen = 3 * AES_BLOCK_SIZE,
	.out_cryptdata = {
		0xd2, 0x63, 0x22, 0x8b, 0x8c, 0xe0, 0x51, 0xf6, 0x7e, 0x9b, 0xaf, 0x1c, 0xe7, 0xdf, 0x97, 0xd1,
		0x0c, 0xd5, 0xf3, 0xbc, 0x97, 0x23, 0x62, 0x05, 0x51, 0x30, 0xc7, 0xd1, 0x3c, 0x3a, 0xb2, 0xe7,
	},
	.tag = {
		0x71, 0x44, 0x67, 0x37, 0xca, 0x1f, 0xa9, 0x2e, 0x6d, 0x02, 0x6d, 0x7d, 0x2e, 0xd1, 0xaa, 0x9c,
	},
	.taglen = GCM_TAGLEN,
},
{
	.key = {
		0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
	},
	.keylen = AES_KEY128_SIZE,
	.iv = {
		0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88,
	},
	.ivlen = GCM_IV_SIZE,
	.in_cryptdata = {
		0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
		0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
		0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
		0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39,
	},
	.cryptlen = 3 * AES_BLOCK_SIZE + 12,
	.assocdata = {
		0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
		0xab, 0xad, 0xda, 0xd2,
	},
	.assoclen = AES_BLOCK_SIZE + 4,
	.out_cryptdata = {
		0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,
		0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,
		0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
		0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91,
	},
	.tag = {
		0x5b, 0xc9, 0x4f, 0xbc, 0x32, 0x21, 0xa5, 0xdb, 0x94, 0xfa, 0xe9, 0x5a, 0xe7, 0x12, 0x1a, 0x47
	},
	.taglen = GCM_TAGLEN,

}};

static int test_gcm_vectors(void)
{
	int ret;

	struct sockaddr_alg sa;
	struct crypto_op *cop;

	int i = 0;

	memset(&sa, 0, sizeof(struct sockaddr_alg));
	sa.salg_family = AF_ALG;
	strncpy((char *)sa.salg_type, "aead", 14);
	strncpy((char *)sa.salg_name, "gcm(aes)", 60);

	for (i = 0; i < sizeof(gcm_vecs) / sizeof(gcm_vecs[0]); ++i) {
		struct gcm_test_vector *vec;
		uint8_t *data;
		uint8_t *aad;
		uint8_t *cryptdata;
		uint8_t *tag;
		size_t keylen;
		size_t ivlen;
		size_t datalen;
		size_t cryptlen;
		size_t assoclen;
		size_t taglen;

		vec = gcm_vecs + i;

		printf(" -- GCM test vector -- \n");
		dump_buffer(stdout, "key: ", vec->key, vec->keylen);
		dump_buffer(stdout, "iv: ", vec->iv, vec->ivlen);
		dump_buffer(stdout, "assocdata: ", vec->assocdata, vec->assoclen);
		dump_buffer(stdout, "in_cryptdata: ", vec->in_cryptdata, vec->cryptlen);
		dump_buffer(stdout, "out_cryptdata: ", vec->out_cryptdata, vec->cryptlen);
		dump_buffer(stdout, "tag: ", vec->tag, vec->taglen);
		printf("\n");

		keylen = vec->keylen;
		ivlen = vec->ivlen;
		assoclen = vec->assoclen;
		cryptlen = vec->cryptlen;
		taglen = vec->taglen;

		datalen = assoclen + cryptlen + taglen;
		alloc_buffer(&data, datalen);

		aad = data;
		cryptdata = data + assoclen;
		tag = cryptdata + cryptlen;

		memcpy(aad, vec->assocdata, assoclen);
		memcpy(cryptdata, vec->in_cryptdata, cryptlen);
		memcpy(tag, vec->tag, taglen);

		// Allocate and initialize struct crypto_op
		cop = crypto_op_create();
		crypto_op_init(cop, ivlen, assoclen, taglen);

		// Open socket, run bind() and accept()
		ret = af_alg_sock_setup(cop, &sa);
		if (ret) {
			fprintf(stderr, "af_alg_sock_setup() failed!\n");
			return -1;
		}

		af_alg_set_key(cop, vec->key, keylen);
		af_alg_set_iv(cop, vec->iv);

		if (taglen)
			af_alg_set_taglen(cop);

		if (assoclen)
			af_alg_set_aadlen(cop);

		encrypt(cop, data, assoclen + cryptlen, data, datalen);
		buf_eq("ciphertext", cryptdata, vec->out_cryptdata, cryptlen);
		buf_eq("tag", tag, vec->tag, taglen);

		decrypt(cop, data, assoclen + cryptlen + taglen,
						data, assoclen + cryptlen);
		buf_eq("plaintext", cryptdata, vec->in_cryptdata, cryptlen);

		crypto_op_finish(cop);

		printf("PASS!\n");
	}

	return 0;
}

int main (int argc, char **argv)
{
	test_gcm_vectors();

	return 0;
}
